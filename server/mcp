#!/usr/bin/env python
"""
Below any parameter requiring a node, status, user, or property accepts a symbolic name such as 'eth0' or 'cu3cn34'
"""

import os
import sys
import socket
import getopt
import time
import master
import mimetypes
from xmlrpclib import Fault
from twisted.enterprise import adbapi
from twisted.internet import reactor, task
from twisted.web import xmlrpc, server, http, resource, rewrite
from twisted.names import client

debug = False

connPool=None
#def dbRO(function):
#	def newfunc(*arguments):
#		try:
#			connection = connPool.acquire()
#		except pgdb.InternalError, e:
#			raise Failure(30, "Database Error, Try again later", e)
#		try:
#			replayCommandQueue(connection)
#			return function(connection, *arguments)
#		finally:
#			connPool.release(connection)
#	newfunc.__name__ = function.__name__
#	return newfunc
#
#def dbRW(function):
#	def newfunc(*arguments):
#		try:
#			connection = connPool.acquire()
#		except pgdb.InternalError, e:
#			commandQueue.append((function, arguments))
#			raise Failure(40, "Database Error, Update queued", e)
#		try:
#			replayCommandQueue(connection)
#			return function(connection,*arguments)
#		finally:
#			connPool.release(connection)
#	newfunc.__name__ = function.__name__
#	return newfunc

def epochTo8601(epoch):
	try:
		return time.strftime("%F %T", time.localtime(epoch))
	except TypeError:
		return epoch

def Failure(code,message,srvdbg=""):
	"""Return an xmlrpclib.Fault after calling the current master.debug function"""
	master.debug("Failure %s:%s:%s"%tuple([str(x) for x in code,message,srvdbg]))
	return Fault(code,message)
		
class Authorizer:
	"A Mixin class to do authorization checks on resource requests"

	def authorize(self, request, authorizedCallback):
		"call authorizedCallback if the host is in the db, otherwise return an unauthorized message"

		def returnAuthorized():
			authorizedCallback()

		def returnError(msg):
			"return an unauthorized message"
			request.setResponseCode(http.UNAUTHORIZED)
			request.write("<html><title>Unauthorized</title><body><h1>401: Unauthorized</h1></body></html>")
			request.finish()
			master.debug("Error in Authorization: "+str(msg))
			
		def checkCount(res):
			"if there is an entry in the db, then we can talk to this host"
			if res[0][0] > 0:
				return returnAuthorized()
			else:
				returnError("Host not found in Database")

		def dbLookup(res):
			"After finding the hostname, strip off the longest search domain and look it up in the db"
			hostname = str(res[0][0].payload.name)
			for i in self.search:
				ind = hostname.rfind(i)
				if ind != -1:
					hostname = hostname[0:ind-1]
					break
			connPool.runQuery("select count(*) from node where name = %(client_name)s", {"client_name":hostname}
					).addCallback(checkCount
					).addErrback(returnError)

		if request.client.host == "127.0.0.1" or master.config["mcp_host_authorization"] == False:
			returnAuthorized()
			return server.NOT_DONE_YET
		else:
			#because twisted doesn't have a reverse lookup, I have to do a pointer record lookup
			client.lookupPointer('.'.join(request.client.host.split('.')[::-1]) + '.in-addr.arpa'
						).addCallback(dbLookup
						).addErrback(returnError)
			#this *should* be ok to do because I am in the main thread
			self.search = []
			for i in open("/etc/resolv.conf"):
				if i.find("search") == 0 or i.find("domain") == 0:
					self.search += i[:-1].split()[1:]
			self.search.sort(lambda l,r: len(r) - len(l))
			return server.NOT_DONE_YET

class ForwardToWeb(resource.Resource):
	"A class to forward any requests to the web directory"
	isLeaf = True
	def render(self, request):
		request.setResponseCode(http.MOVED_PERMANENTLY)
		request.setHeader("Location", "web/")
		return ""

class MasterWebServerFile(resource.Resource, Authorizer):
	"Lookup a file in the web_directory and return it to the client"
	isLeaf=True
	def render_GET(self, request):
		def response():
			fullpath = "%s/%s" % (master.config["web_directory"],"/".join(request.prepath[1:]))
			request.setHeader("Content-type",mimetypes.guess_type(fullpath)[0])
       			request.write(open(fullpath).read())
			request.finish()
		return self.authorize(request, response)

class MasterWebServer(resource.Resource):
	"""The base web server directory class.  If requested directly, forward to the directory. If 
	the directory is requested, see if there is a file in the config["web_directory"] and load it
	by calling the MasterWebServerFile class"""
	isLeaf=False
	def render(self, request):
		request.setResponseCode(http.MOVED_PERMANENTLY)
		request.setHeader("Location", "web/")
		return ""

	def getChild(self, path, request):
		if path == "":
			path = request.prepath[-1] = "index.html"
		fullpath = "%s/%s/%s" % (master.config["web_directory"],"/".join(request.prepath[1:-1]),path)
		if os.path.isfile(fullpath):
			return MasterWebServerFile()
		elif os.path.isdir(fullpath):
			return MasterWebServer()
		else:
			return resource.Resource.getChild(self, path, request)

class MasterXMLRPCBase(xmlrpc.XMLRPC, Authorizer):
	"Check to see if the client is autorized in an xmlrpc call"
	def render(self, request):
		def renderAuthorized():
			return xmlrpc.XMLRPC.render(self, request)
		return self.authorize(request, renderAuthorized)

class MasterXMLRPCServer(xmlrpc.XMLRPC):
	#@dbRW
	def xmlrpc_addNode(self, name):
		"""addNode(name) -> Boolean
		
		Create a new node. 
		Returns new nodes unique ID or xmlrpclib.Fault on Error"""
		return connPool.runOperation("insert into node (name) values (%(name)s)", {"name":name}
			).addCallback(lambda a: True
			).addErrback(lambda a: Failure(10, "addNode failed for %s"%name, a))
	xmlrpc_addNode.signature = [["bool","string"]]

	#@dbRO
	def xmlrpc_getNodes(self, filter=False):
		"""getNodes(filter=False) -> ['name1','name2',...]
		
		Get a list of nodes
		filter - A filter on what names should be returned. uses standard sql wildcards (i.e. n% matches n10)
		"""
		return connPool.runQuery("select name from node" + {True:" where name like %(filter)s",False:""}[filter!=False], {"filter":filter}
			).addErrback(lambda a: Failure(20,"getNodes failed: filter=%s"%(str(filter)),a))
	xmlrpc_getNodes.signature = [["array"], ["array", "string"]]

	#@dbRW
	def xmlrpc_addStatus(self, name,desc = ''):
		"""addStatus(name,desc = '') -> Boolean
		
		Create a new status type, with name and descripition.  
		Returns new status ID or xmlrpclib.Fault on error"""
		return connPool.runOperation("insert into status (name, description) values (%(name)s, %(desc)s)", {"name":name, "desc":desc}
			).addCallback(lambda a: True
			).addErrback(lambda msg: Failure(10,"addStatus failed for %s:%s"%(name,desc),msg))
	xmlrpc_addStatus.signature = [["bool", "string"], ["bool", "string", "string"]]
	
	
	#@dbRO
	def xmlrpc_getStatus(self, names=False):
		"""getStatus(names=False) -> {'name':'Description',...}
		
		Get a list of statuses.
		names - a list of status names, if list is empty return all statuses
		"""
		return connPool.runQuery("select name, description from status" + {True:" where name in %(names)s",False:""}[names!=False], {"names":names}
			).addCallback(lambda res: dict(res)
			).addErrback(lambda msg: Failure(20,"getStatus failed for %s"%(str(names)), msg))
	xmlrpc_getStatus.signature = [["struct"],["struct", "array"]]
	
	#@dbRW
	def xmlrpc_addProperty(self, name,desc = ''):
		"""addProperty(name,desc = '') -> Boolean
		
		Create a new property type, with name and descripition.  
		Returns new status ID or xmlrpclib.Fault on Error"""
		return connPool.runOperation("insert into property (name, description) values (%(name)s, %(desc)s)", {"name":name, "desc":desc}
			).addCallback(lambda a:True
			).addErrback(lambda msg:Failure(10,"addProperty failed for %s:%s"%(name,desc),msg))
	xmlrpc_addProperty.signature = [["bool", "string"], ["bool", "string", "string"]]
	
	#@dbRO
	def xmlrpc_getProperties(self, names=False):
		"""getProperties(names=[]) -> {'name':'Description',...}
		
		Get a list of properties as a dictionary
		names - a list of property names, if list is empty return all properties
		"""
		return connPool.runQuery("select name, description from property" + {True:" where name in %(names)s",False:""}[names!=False], {"names":names}
			).addCallback(lambda res: dict(res)
			).addErrback(lambda msg: Failure(20,"getProperties failed for %s"%(str(names)), msg))
	xmlrpc_getProperties.signature = [["struct"], ["struct", "array"]]
	
	#@dbRW
	def xmlrpc_addUser(self, name,fullname):
		"""addUser(name,fullname) -> Boolean
		
		Add a user in the database.
		name - unique username, should match unix username such as 'efelix'
		fullname - Printable Name of the user such as 'Evan J. Felix'
		"""
		return connPool.runOperation("insert into users (username,name) values (%(name)s,%(fullname)s)", {"name":name, "fullname":fullname}
			).addCallback(lambda a: True
			).addErrback(lambda msg: Failure(10,"addUser failed for %s:%s"%(name,fullname),msg))
	xmlrpc_addUser.signature = [["bool", "string", "string"]]
	
	#@dbRO
	def xmlrpc_getUsers(self, names=False):
		"""getUsers(names=[]) -> {'username':'fullname',...}
		
		Get a list of users.  
		names - a list of usernames, if list is empty return all users
		"""
		return connPool.runQuery("select username, name from users" + {True:" where username in %(names)s",False:""}[names!=False], {"names":names}
			).addCallback(lambda res: dict(res)
			).addErrback(lambda msg: Failure(20,"getUsers failed for %s"%(str(names)),msg))
	xmlrpc_getUsers.signature = [["struct"], ["struct", "array"]]
	
	#FIXME I may need to get a static time when "now" is passed
	#@dbRW
	def xmlrpc_updateStatus(self, nodes,status,user,comment="",time="now"):
		"""updateStatus(nodes,status,user,comment,timeistamp) -> Boolean
		
		Change the status of a list of nodes.  
		Comments and timestamp are optional
		Returns True on success, xmlrpclib.Fault on Error
		"""
		def updateStatus(txn, node, status, user, comment, time):
			txn.executemany("""insert into node_status_log (node_id, status_id, time, comment, user_id) values (
						(select id from node where name = %(node)s), 
						(select id from status where name = %(status)s), %(time)s, %(comment)s,
						(select id from users where username = %(user)s))""",
						[{"node":i, "status":status, "time":epochTo8601(time), "comment":comment, "user":user} for i in nodes]
				)
		return connPool.runInteraction(updateStatus, nodes, status, user, comment, time
				).addCallback(lambda a: True
				).addErrback(lambda msg: Failure(10,"updateStatus failed for %s"%(str((nodes,status,user,comment,time))),msg))
	xmlrpc_updateStatus.signature = [	["bool", "array", "string", "string"],
						["bool", "array", "string", "string", "string"],
						["bool", "array", "string", "string", "string", "dateTime.iso8601"]]

	#@dbRO
	def xmlrpc_getNodeStatus(self, nodes):
		"""getCurrentStatus(nodes) -> {'node1':(statusName,timeStamp,user,comment),...}
		
		Retrieve the current status of a node or set of nodes
		The nodes parameter is a list of nodes to get status for
		Timestamps are a POSIX timestamp
		"""
		#should I use subqueries for these views?
		return connPool.runQuery("""select node.name, status.name, extract(epoch from last_change)::int4, users.username, comment 
						from node_status, node, status, users 
						where node_status.node_id = node.id and node_status.status_id = status.id 
						and users.id = user_id and node.name in %(nodes)s""", {"nodes":nodes}
			).addCallback(lambda res:dict([(i[0],i[1:]) for i in res])
			).addErrback(lambda msg: Failure(20,"getNodeStatus failed for %s"%(str(nodes)),msg))
	xmlrpc_getNodeStatus.signature = ["struct", "array"]

	#@dbRO
	def xmlrpc_getStatusHistory(self, nodes,filter=False,startTime='-infinity',endTime='infinity'):
		"""getStatusHistory(nodes,filter=false,startTime=-infinity,endTime=inifinity) -> {'node1':[(statusName,timestamp,user,comment),...],'node2':...}
	
		Retrieve a ordered list of status changes in a time period for a list of nodes
		Nodes that are not in the system will be silently ignored.
	
		filter - set of status names that are allowed to be returned
		*Time - Date & Time for start and end of data requested.  
		
		Timestamp values are the strings 'now','-infinity', 'infinity' or a integer representing a POSIX timestamp
		"""
		def format_history(res):
			ret = {}
			for i in res:
				try:
					ret[i[0]] += [i[1:]]
				except KeyError:
					ret[i[0]] = [i[1:]]
			return ret

		return connPool.runQuery("""select node.name, s.name, extract(epoch from time), users.username, comment 
				from node_status_log, node, status s, users
				where node.id = node_id and s.id = status_id and users.id = user_id
				and node.name in %(nodes)s and time between %(start)s and %(end)s """ +
				{True:"", False:"and s.name in %(status)s "}[filter == False] +
	 			"order by time", {"nodes":nodes, "status":filter, "start":epochTo8601(startTime), "end":epochTo8601(endTime)}
				).addCallback(format_history
				).addErrback(lambda msg: Failure(20, "getStatusHistory Failed for %s"%(str((nodes,filter,startTime,endTime))),msg))
	xmlrpc_getStatusHistory.signature = [	["struct", "array"],
					["struct", "array", "string"],
					["struct", "array", "string", "int"],
					["struct", "array", "string", "int", "int"]]
	
	#FIXME return bool or timestamp?
	#@dbRW
	def xmlrpc_updateNodeProperty(self, node,property,propertyValue,comment="",time="now"):
		"""updateProperty(node,property,propertyValue,comment="",time="now") -> timestamp
		
		Update a property value of a list of nodes.
			node		- node to set the property on
			property	- Property to change, name
			propertyValue	- value to change property to.
			comment		- user comment on this change
			time		- a timestamp for the change.  Defaults to 'now'
		
		Returns timestamp of change, or xmlrpclib.Fault on error
			
		Timestamp values are the strings 'now','-infinity', 'infinity' or a integer representing a POSIX timestamp
		"""
		return connPool.runOperation("""insert into node_properties_log (node_id, property_id, time, value, comment)
						values ((select id from node where name = %(node)s),
						(select id from property where name = %(property)s),
						%(time)s, %(propertyValue)s, %(comment)s)""",
						{"node":node, "property":property, "time":epochTo8601(time),
						"propertyValue":propertyValue, "comment":comment}
						).addCallback(lambda a: True
						).addErrback(lambda msg: Failure(10,"updateNodeProperty failed for %s"%(str((node,property,propertyValue,comment,time))),msg))
	xmlrpc_updateNodeProperty.signature = [	["dateTime.iso8601", "string", "string", "string"],
						["dateTime.iso8601", "string", "string", "string", "string"],
						["dateTime.iso8601", "string", "string", "string", "string", "dateTime.iso8601"]]
	
	#@dbRO
	def xmlrpc_getNodeProperties(self, nodes,filter=False):
		"""getNodeProperties(nodes,filter=False) -> {'node1':[(propName,value,timestamp,comment),...],'node2':[...],...}
		
		Retrieve the current properties of the given nodes.
		a filter is a list of id's allowed ("eth0mac","eth1mac")
		Returns a dictionary of tuples containing (propName,value,timestamp,comment)
		Timestamps are a POSIX timestamp
		"""
	
		def format_properties(res):
			retVal = {}
			for i in res:
				try:
					retVal[i[0]].append(i[1:5])
				except KeyError:
					retVal[i[0]] = [i[1:5]]
			return retVal

		if type(filter) == type(""):
			filter = [filter]
		return connPool.runQuery("""select node.name, property.name, value, extract(epoch from last_change)::int4, comment 
					from node_properties, node, property 
					where node_properties.node_id = node.id and node_properties.property_id = property.id
					and node.name in %(nodes)s """ +
					{True:"", False:"and property.name in %(filter)s "}[filter == False] +
					"order by last_change",
					{"nodes":nodes, "filter":filter}
					).addCallback(format_properties
					).addErrback(lambda msg: Failure(20,"getNodeProperties failed for %s"%(str((nodes,filter))),msg))
	xmlrpc_getNodeProperties.signature = [["struct", "array"], ["struct", "array", "string"], ["struct", "array", "array"]]
	
	#@dbRO
	def xmlrpc_getNodePropertyHistory(self, nodes,filter=False,startTime='-infinity',endTime='infinity'):
		"""getNodePropertyHistory(nodes,filter=False,startTime='-infinity',endTime='infinity') -> {'node1':[(propName,value,timestamp,comment),...],'node2':[...],...}
		
		Retrieve all property change logs for a given period.
		If a time period is not specified returns all records.
		
		filter is a list of property names allowed ("eth0mac","eth1mac")
		*Time - Date & Time for start and end of data requested
		Timestamp values are the strings 'now','-infinity', 'infinity' or a integer representing a POSIX timestamp
		"""
		def formatNodePropertyHistory(res):
			retDict = {}
			for i in res:
				try:
					retDict[i[0]] += [i[1:5]]
				except KeyError:
					retDict[i[0]] = [i[1:5]]
			return retDict

		return connPool.runQuery("""select node.name, p.name, value, extract(epoch from time)::int4, comment 
					from node_properties_log, node, property p where node.id = node_id and p.id = property_id 
					and node.name in %(nodes)s and time between %(start)s and %(end)s """ +
					{True:"", False:"and p.name in %(filter)s "}[filter == False] +
					 "order by time",
					{"nodes":nodes, "filter":filter, "start":epochTo8601(startTime), "end":epochTo8601(endTime)}
			).addCallback(formatNodePropertyHistory
			).addErrback(lambda msg: Failure(20,"getNodePropertyHistory failed for %s"%(str((nodes,filter,startTime,endTime))),msg))
	
	xmlrpc_getNodePropertyHistory.signature = [	["struct", "array"],
							["struct", "array", "array"],
							["struct", "array", "array", "int"],
							["struct", "array", "array", "int", "int"]]
	#@dbRO
	def xmlrpc_serverTime(self):
		"""serverTime -> float

		returns the current time of the server as a POSIX timestamp
		"""

		return connPool.runQuery("select extract(epoch from now())::int4"
					).addCallback(lambda a:a[0][0]
					).addErrback(lambda msg: Failure(20,"retrieving time failed ",msg))
	xmlrpc_serverTime.signature = [["int"]]



def daemonize(user = None, group = None):
	import pwd
	pid = os.fork()
	if pid > 0:
		sys.exit(0)

	os.chdir("/")
	os.setsid()
	os.umask(0)

	pid = os.fork()
	if pid > 0:
		sys.exit(0)

	sys.stdout.close()
	sys.stderr.close()
	os.close(0)
	os.close(1)
	os.close(2)

	if user:
		os.seteuid(pwd.getpwnam(user)[2])
	if group:
		os.setegid(group)

def main():
	"""Function to start up the server and serve the pages till the end of time."""
	global connPool
	global debug

	optlist,args = getopt.getopt(sys.argv[1:],'d')
	for (arg,val) in optlist:
		if arg == '-d':
			debug=1
		if arg == "-c":
			master.config["config_file"]=val
	
	master.load_config()
	
	if not debug:
		daemonize()
	else:
		master.debug = master.basicdebug

	#TODO make numConnections configurable
	connPool = adbapi.ConnectionPool(
		"pgdb",
		user=master.config["database_user"], 
		database=master.config["database_name"], 
		password=master.config["database_password"],
		host=master.config["database_server"],
		cp_reconnect = True,
		cp_min = int(master.config["database_min_connections"]),
		cp_max = int(master.config["database_max_connections"])
	)
	
	#create an xmlrpc directory structure resource and put it in the master xmlrpc directory
	m = MasterXMLRPCBase()
	m.putSubHandler('master', MasterXMLRPCServer())
	xmlrpc.addIntrospection(m)
	root = resource.Resource()
	root.putChild("RPC2", m)

	#if we are configure to have a web interface create the resources and put it in the web directory
	if master.config["web_interface"] == True:
		root.putChild("web", MasterWebServer())
		root.putChild("", ForwardToWeb())

	#go
	reactor.listenTCP(master.config["mcp_port"], server.Site(root))
	reactor.run()

if __name__ == "__main__":
	try:
		main()
	except KeyboardInterrupt:
		pass
